START COUNTING
START COUNTING
START COUNTING
START COUNTING
START COUNTING
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 2 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 2 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 2 __contributors__ = []

CODE LINE 2 _debug = 0

BLANK LINE 3 

CODE LINE 3 import collections

CODE LINE 3 from weakref import proxy

BLANK LINE 4 

CODE LINE 4 class Link(object):

CODE LINE 4     '''

CODE LINE 4     The proper use of __slots__ is to save space in objects.

CODE LINE 4     '''

CODE LINE 4     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 5 class LinkedList(collections.MutableSet):

CODE LINE 5     '''

CODE LINE 5     LinkedLink

CODE LINE 5     Set the remembers the order elements were added

CODE LINE 5     '''

BLANK LINE 6 

CODE LINE 6     def __init__(self, iterable=None):

CODE LINE 6         '''

CODE LINE 6         Init

CODE LINE 6         '''

CODE LINE 6         self.__root = root = Link()         

CODE LINE 6         root.prev = root.next = root

CODE LINE 6         self.__map = {}                     # key --> link

CODE LINE 6         if iterable is not None:

CODE LINE 6             self |= iterable

BLANK LINE 7 

CODE LINE 7     def __len__(self):

CODE LINE 7         '''

CODE LINE 7         Length for the LinkedList

CODE LINE 7         '''

CODE LINE 7         return len(self.__map)

BLANK LINE 8 

CODE LINE 8     def __contains__(self, key):

CODE LINE 8         '''

CODE LINE 8         Return Content of LinkedList

CODE LINE 8         '''

CODE LINE 8         return key in self.__map

BLANK LINE 9 

CODE LINE 9     def add(self, key):

CODE LINE 9         '''

CODE LINE 9         Add Node

CODE LINE 9         Store new key in a new link at the end of the linked list

CODE LINE 9         '''

CODE LINE 9         if key not in self.__map:

CODE LINE 9             '''

CODE LINE 9             Not Element Eq in the list

CODE LINE 9             '''

CODE LINE 9             self.__map[key] = link = Link()            

CODE LINE 9             root = self.__root

CODE LINE 9             last = root.prev

CODE LINE 9             link.prev, link.next, link.key = last, root, key

CODE LINE 9             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 10     def head(self):

CODE LINE 10         '''

CODE LINE 10         Return Head

CODE LINE 10         '''

CODE LINE 10         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 12     def discard(self, key):

CODE LINE 12         '''

CODE LINE 12         Remove an existing item using self.__map to find the link which is

CODE LINE 12         then removed by updating the links in the predecessor and successors.

CODE LINE 12         '''

CODE LINE 12         if key in self.__map:

CODE LINE 12             link = self.__map.pop(key)

CODE LINE 12             link.prev.next = link.next

CODE LINE 12             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 13     def __iter__(self):

CODE LINE 13         '''

CODE LINE 13         iteration for the Next Method

CODE LINE 13         '''

CODE LINE 13         root = self.__root

CODE LINE 13         curr = root.next

CODE LINE 13         while curr is not root:

CODE LINE 13             yield curr.key

CODE LINE 13             curr = curr.next

BLANK LINE 14 

CODE LINE 14     def __reversed__(self):

CODE LINE 14         '''

CODE LINE 14         iteration in reverse mode Method

CODE LINE 14         '''

CODE LINE 14         root = self.__root

CODE LINE 14         curr = root.prev

CODE LINE 14         while curr is not root:

CODE LINE 14             yield curr.key

CODE LINE 14             curr = curr.prev

BLANK LINE 15 

CODE LINE 15     def pop(self, last=True):

CODE LINE 15         '''

CODE LINE 15         pop key

CODE LINE 15         '''

CODE LINE 15         if not self:

CODE LINE 15             raise KeyError('set is empty')

CODE LINE 15         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 15         self.discard(key)

CODE LINE 15         return key

BLANK LINE 16 

CODE LINE 16     def __repr__(self):

CODE LINE 16         '''

CODE LINE 16         String Conversion representation of object LinkeList repr()

CODE LINE 16         '''

CODE LINE 16         if not self:

CODE LINE 16             return '%s()' % (self.__class__.__name__,)

CODE LINE 16         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 17     def __eq__(self, other):

CODE LINE 17         '''

CODE LINE 17         Method for de Equal comparation.

CODE LINE 17         '''

CODE LINE 17         if isinstance(other, LinkedList):

CODE LINE 17             return len(self) == len(other) and list(self) == list(other)

CODE LINE 17         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{} 
 TOTAL LINES:142 
 BLANK LINE:17 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 2 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 2 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 2 __contributors__ = []

CODE LINE 2 _debug = 0

BLANK LINE 3 

CODE LINE 3 import collections

CODE LINE 3 from weakref import proxy

BLANK LINE 4 

CODE LINE 4 class Link(object):

CODE LINE 4     '''

CODE LINE 4     The proper use of __slots__ is to save space in objects.

CODE LINE 4     '''

CODE LINE 4     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 5 class LinkedList(collections.MutableSet):

CODE LINE 5     '''

CODE LINE 5     LinkedLink

CODE LINE 5     Set the remembers the order elements were added

CODE LINE 5     '''

BLANK LINE 6 

CODE LINE 6     def __init__(self, iterable=None):

CODE LINE 6         '''

CODE LINE 6         Init

CODE LINE 6         '''

CODE LINE 6         self.__root = root = Link()         

CODE LINE 6         root.prev = root.next = root

CODE LINE 6         self.__map = {}                     # key --> link

CODE LINE 6         if iterable is not None:

CODE LINE 6             self |= iterable

BLANK LINE 7 

CODE LINE 7     def __len__(self):

CODE LINE 7         '''

CODE LINE 7         Length for the LinkedList

CODE LINE 7         '''

CODE LINE 7         return len(self.__map)

BLANK LINE 8 

CODE LINE 8     def __contains__(self, key):

CODE LINE 8         '''

CODE LINE 8         Return Content of LinkedList

CODE LINE 8         '''

CODE LINE 8         return key in self.__map

BLANK LINE 9 

CODE LINE 9     def add(self, key):

CODE LINE 9         '''

CODE LINE 9         Add Node

CODE LINE 9         Store new key in a new link at the end of the linked list

CODE LINE 9         '''

CODE LINE 9         if key not in self.__map:

CODE LINE 9             '''

CODE LINE 9             Not Element Eq in the list

CODE LINE 9             '''

CODE LINE 9             self.__map[key] = link = Link()            

CODE LINE 9             root = self.__root

CODE LINE 9             last = root.prev

CODE LINE 9             link.prev, link.next, link.key = last, root, key

CODE LINE 9             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 10     def head(self):

CODE LINE 10         '''

CODE LINE 10         Return Head

CODE LINE 10         '''

CODE LINE 10         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 12     def discard(self, key):

CODE LINE 12         '''

CODE LINE 12         Remove an existing item using self.__map to find the link which is

CODE LINE 12         then removed by updating the links in the predecessor and successors.

CODE LINE 12         '''

CODE LINE 12         if key in self.__map:

CODE LINE 12             link = self.__map.pop(key)

CODE LINE 12             link.prev.next = link.next

CODE LINE 12             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 13     def __iter__(self):

CODE LINE 13         '''

CODE LINE 13         iteration for the Next Method

CODE LINE 13         '''

CODE LINE 13         root = self.__root

CODE LINE 13         curr = root.next

CODE LINE 13         while curr is not root:

CODE LINE 13             yield curr.key

CODE LINE 13             curr = curr.next

BLANK LINE 14 

CODE LINE 14     def __reversed__(self):

CODE LINE 14         '''

CODE LINE 14         iteration in reverse mode Method

CODE LINE 14         '''

CODE LINE 14         root = self.__root

CODE LINE 14         curr = root.prev

CODE LINE 14         while curr is not root:

CODE LINE 14             yield curr.key

CODE LINE 14             curr = curr.prev

BLANK LINE 15 

CODE LINE 15     def pop(self, last=True):

CODE LINE 15         '''

CODE LINE 15         pop key

CODE LINE 15         '''

CODE LINE 15         if not self:

CODE LINE 15             raise KeyError('set is empty')

CODE LINE 15         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 15         self.discard(key)

CODE LINE 15         return key

BLANK LINE 16 

CODE LINE 16     def __repr__(self):

CODE LINE 16         '''

CODE LINE 16         String Conversion representation of object LinkeList repr()

CODE LINE 16         '''

CODE LINE 16         if not self:

CODE LINE 16             return '%s()' % (self.__class__.__name__,)

CODE LINE 16         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 17     def __eq__(self, other):

CODE LINE 17         '''

CODE LINE 17         Method for de Equal comparation.

CODE LINE 17         '''

CODE LINE 17         if isinstance(other, LinkedList):

CODE LINE 17             return len(self) == len(other) and list(self) == list(other)

CODE LINE 17         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part False: running_item.name : __init__
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7fe877f21a50>, 'LinkedList': <__main__.Item object at 0x7fe877f21b10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7f4119bd3a50>, 'LinkedList': <__main__.Item object at 0x7f4119bd3b10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7f7c06d10a50>, 'LinkedList': <__main__.Item object at 0x7f7c06d10b10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0xc90a50>, 'LinkedList': <__main__.Item object at 0xc90b10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7fcd48befa50>, 'LinkedList': <__main__.Item object at 0x7fcd48befb10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7f2164cfba50>, 'LinkedList': <__main__.Item object at 0x7f2164cfbb10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7fadc8e92a50>, 'LinkedList': <__main__.Item object at 0x7fadc8e92b10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7f4e0797ca50>, 'LinkedList': <__main__.Item object at 0x7f4e0797cb10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7fc2ac3cea50>, 'LinkedList': <__main__.Item object at 0x7fc2ac3ceb10>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

COMENT LINE 2 # -*- coding: utf-8 -*-

COMENT LINE 3 #

COMENT LINE 4 #       mean_std.py

COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

COMENT LINE 6 #       

COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

COMENT LINE 10 #       (at your option) any later version.

COMENT LINE 11 #       

COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

COMENT LINE 15 #       GNU General Public License for more details.

COMENT LINE 16 #       

COMENT LINE 17 #       You should have received a copy of the GNU General Public License

COMENT LINE 18 #       along with this program; if not, write to the Free Software

COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

COMENT LINE 20 #       MA 02110-1301, USA.

BLANK LINE 1 

BLANK LINE 2 

CODE LINE 1 __version__ = "0.0.1"

CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

CODE LINE 4 __contributors__ = []

CODE LINE 5 _debug = 0

BLANK LINE 3 

CODE LINE 6 import collections

CODE LINE 7 from weakref import proxy

BLANK LINE 4 

CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

CODE LINE 9     '''

CODE LINE 10     The proper use of __slots__ is to save space in objects.

CODE LINE 11     '''

CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

BLANK LINE 5 

CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

CODE LINE 14     '''

CODE LINE 15     LinkedLink

CODE LINE 16     Set the remembers the order elements were added

CODE LINE 17     '''

BLANK LINE 6 

CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

CODE LINE 19         '''

CODE LINE 20         Init

CODE LINE 21         '''

CODE LINE 22         self.__root = root = Link()         

CODE LINE 23         root.prev = root.next = root

CODE LINE 24         self.__map = {}                     # key --> link

CODE LINE 25         if iterable is not None:

CODE LINE 26             self |= iterable

BLANK LINE 7 

CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

CODE LINE 28         '''

CODE LINE 29         Length for the LinkedList

CODE LINE 30         '''

CODE LINE 31         return len(self.__map)

BLANK LINE 8 

CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

CODE LINE 33         '''

CODE LINE 34         Return Content of LinkedList

CODE LINE 35         '''

CODE LINE 36         return key in self.__map

BLANK LINE 9 

CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

CODE LINE 38         '''

CODE LINE 39         Add Node

CODE LINE 40         Store new key in a new link at the end of the linked list

CODE LINE 41         '''

CODE LINE 42         if key not in self.__map:

CODE LINE 43             '''

CODE LINE 44             Not Element Eq in the list

CODE LINE 45             '''

CODE LINE 46             self.__map[key] = link = Link()            

CODE LINE 47             root = self.__root

CODE LINE 48             last = root.prev

CODE LINE 49             link.prev, link.next, link.key = last, root, key

CODE LINE 50             last.next = root.prev = proxy(link)

BLANK LINE 10     

CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

CODE LINE 52         '''

CODE LINE 53         Return Head

CODE LINE 54         '''

CODE LINE 55         return list(self)[0],list(self)[-1] 

BLANK LINE 11         

BLANK LINE 12 

CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

CODE LINE 57         '''

CODE LINE 58         Remove an existing item using self.__map to find the link which is

CODE LINE 59         then removed by updating the links in the predecessor and successors.

CODE LINE 60         '''

CODE LINE 61         if key in self.__map:

CODE LINE 62             link = self.__map.pop(key)

CODE LINE 63             link.prev.next = link.next

CODE LINE 64             link.next.prev = link.prev

BLANK LINE 13 

CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

CODE LINE 66         '''

CODE LINE 67         iteration for the Next Method

CODE LINE 68         '''

CODE LINE 69         root = self.__root

CODE LINE 70         curr = root.next

CODE LINE 71         while curr is not root:

CODE LINE 72             yield curr.key

CODE LINE 73             curr = curr.next

BLANK LINE 14 

CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

CODE LINE 75         '''

CODE LINE 76         iteration in reverse mode Method

CODE LINE 77         '''

CODE LINE 78         root = self.__root

CODE LINE 79         curr = root.prev

CODE LINE 80         while curr is not root:

CODE LINE 81             yield curr.key

CODE LINE 82             curr = curr.prev

BLANK LINE 15 

CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

CODE LINE 84         '''

CODE LINE 85         pop key

CODE LINE 86         '''

CODE LINE 87         if not self:

CODE LINE 88             raise KeyError('set is empty')

CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

CODE LINE 90         self.discard(key)

CODE LINE 91         return key

BLANK LINE 16 

CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

CODE LINE 93         '''

CODE LINE 94         String Conversion representation of object LinkeList repr()

CODE LINE 95         '''

CODE LINE 96         if not self:

CODE LINE 97             return '%s()' % (self.__class__.__name__,)

CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

BLANK LINE 17 

CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

CODE LINE 100         '''

CODE LINE 101         Method for de Equal comparation.

CODE LINE 102         '''

CODE LINE 103         if isinstance(other, LinkedList):

CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7fe359630a90>, 'LinkedList': <__main__.Item object at 0x7fe359630b50>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

RUNINGPART:Link  INPART:True
CODE LINE 9     '''

RUNINGPART:Link  INPART:False
CODE LINE 10     The proper use of __slots__ is to save space in objects.

RUNINGPART:Link  INPART:False
CODE LINE 11     '''

RUNINGPART:Link  INPART:False
CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

RUNINGPART:Link  INPART:False
BLANK LINE 5 

RUNINGPART:Link  INPART:False
CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

RUNINGPART:LinkedList  INPART:True
CODE LINE 14     '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 15     LinkedLink

RUNINGPART:LinkedList  INPART:False
CODE LINE 16     Set the remembers the order elements were added

RUNINGPART:LinkedList  INPART:False
CODE LINE 17     '''

RUNINGPART:LinkedList  INPART:False
BLANK LINE 6 

RUNINGPART:LinkedList  INPART:False
CODE LINE 18     def __init__(self, iterable=None):

runinng_part LinkedList: running_item.name : __init__
IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

RUNINGPART:LinkedList  INPART:False
CODE LINE 19         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 20         Init

RUNINGPART:LinkedList  INPART:False
CODE LINE 21         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 22         self.__root = root = Link()         

RUNINGPART:LinkedList  INPART:False
CODE LINE 23         root.prev = root.next = root

RUNINGPART:LinkedList  INPART:False
CODE LINE 24         self.__map = {}                     # key --> link

RUNINGPART:LinkedList  INPART:False
CODE LINE 25         if iterable is not None:

RUNINGPART:LinkedList  INPART:False
CODE LINE 26             self |= iterable

RUNINGPART:LinkedList  INPART:False
BLANK LINE 7 

RUNINGPART:LinkedList  INPART:False
CODE LINE 27     def __len__(self):

runinng_part LinkedList: running_item.name : __len__
IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 28         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 29         Length for the LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 30         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 31         return len(self.__map)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 8 

RUNINGPART:LinkedList  INPART:False
CODE LINE 32     def __contains__(self, key):

runinng_part LinkedList: running_item.name : __contains__
IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 33         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 34         Return Content of LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 35         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 36         return key in self.__map

RUNINGPART:LinkedList  INPART:False
BLANK LINE 9 

RUNINGPART:LinkedList  INPART:False
CODE LINE 37     def add(self, key):

runinng_part LinkedList: running_item.name : add
IN PART LinkedList  ADD ITEM add:     def add(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 38         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 39         Add Node

RUNINGPART:LinkedList  INPART:False
CODE LINE 40         Store new key in a new link at the end of the linked list

RUNINGPART:LinkedList  INPART:False
CODE LINE 41         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 42         if key not in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 43             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 44             Not Element Eq in the list

RUNINGPART:LinkedList  INPART:False
CODE LINE 45             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 46             self.__map[key] = link = Link()            

RUNINGPART:LinkedList  INPART:False
CODE LINE 47             root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 48             last = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 49             link.prev, link.next, link.key = last, root, key

RUNINGPART:LinkedList  INPART:False
CODE LINE 50             last.next = root.prev = proxy(link)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 10     

RUNINGPART:LinkedList  INPART:False
CODE LINE 51     def head(self):

runinng_part LinkedList: running_item.name : head
IN PART LinkedList  ADD ITEM head:     def head(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 52         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 53         Return Head

RUNINGPART:LinkedList  INPART:False
CODE LINE 54         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 55         return list(self)[0],list(self)[-1] 

RUNINGPART:LinkedList  INPART:False
BLANK LINE 11         

RUNINGPART:LinkedList  INPART:False
BLANK LINE 12 

RUNINGPART:LinkedList  INPART:False
CODE LINE 56     def discard(self, key):

runinng_part LinkedList: running_item.name : discard
IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 57         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 58         Remove an existing item using self.__map to find the link which is

RUNINGPART:LinkedList  INPART:False
CODE LINE 59         then removed by updating the links in the predecessor and successors.

RUNINGPART:LinkedList  INPART:False
CODE LINE 60         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 61         if key in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 62             link = self.__map.pop(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 63             link.prev.next = link.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 64             link.next.prev = link.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 13 

RUNINGPART:LinkedList  INPART:False
CODE LINE 65     def __iter__(self):

runinng_part LinkedList: running_item.name : __iter__
IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 66         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 67         iteration for the Next Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 68         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 69         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 70         curr = root.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 71         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 72             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 73             curr = curr.next

RUNINGPART:LinkedList  INPART:False
BLANK LINE 14 

RUNINGPART:LinkedList  INPART:False
CODE LINE 74     def __reversed__(self):

runinng_part LinkedList: running_item.name : __reversed__
IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 75         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 76         iteration in reverse mode Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 77         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 78         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 79         curr = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 80         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 81             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 82             curr = curr.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 15 

RUNINGPART:LinkedList  INPART:False
CODE LINE 83     def pop(self, last=True):

runinng_part LinkedList: running_item.name : pop
IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

RUNINGPART:LinkedList  INPART:False
CODE LINE 84         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 85         pop key

RUNINGPART:LinkedList  INPART:False
CODE LINE 86         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 87         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 88             raise KeyError('set is empty')

RUNINGPART:LinkedList  INPART:False
CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

RUNINGPART:LinkedList  INPART:False
CODE LINE 90         self.discard(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 91         return key

RUNINGPART:LinkedList  INPART:False
BLANK LINE 16 

RUNINGPART:LinkedList  INPART:False
CODE LINE 92     def __repr__(self):

runinng_part LinkedList: running_item.name : __repr__
IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 93         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 94         String Conversion representation of object LinkeList repr()

RUNINGPART:LinkedList  INPART:False
CODE LINE 95         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 96         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 97             return '%s()' % (self.__class__.__name__,)

RUNINGPART:LinkedList  INPART:False
CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

RUNINGPART:LinkedList  INPART:False
BLANK LINE 17 

RUNINGPART:LinkedList  INPART:False
CODE LINE 99     def __eq__(self, other):

runinng_part LinkedList: running_item.name : __eq__
IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

RUNINGPART:LinkedList  INPART:False
CODE LINE 100         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 101         Method for de Equal comparation.

RUNINGPART:LinkedList  INPART:False
CODE LINE 102         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 103         if isinstance(other, LinkedList):

RUNINGPART:LinkedList  INPART:False
CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

RUNINGPART:LinkedList  INPART:False
CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7ff9ce1dfa90>, 'LinkedList': <__main__.Item object at 0x7ff9ce1dfb50>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

RUNINGPART:Link  INPART:True
CODE LINE 9     '''

RUNINGPART:Link  INPART:False
CODE LINE 10     The proper use of __slots__ is to save space in objects.

RUNINGPART:Link  INPART:False
CODE LINE 11     '''

RUNINGPART:Link  INPART:False
CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

RUNINGPART:Link  INPART:False
BLANK LINE 5 

RUNINGPART:Link  INPART:False
CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

RUNINGPART:LinkedList  INPART:True
CODE LINE 14     '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 15     LinkedLink

RUNINGPART:LinkedList  INPART:False
CODE LINE 16     Set the remembers the order elements were added

RUNINGPART:LinkedList  INPART:False
CODE LINE 17     '''

RUNINGPART:LinkedList  INPART:False
BLANK LINE 6 

RUNINGPART:LinkedList  INPART:False
CODE LINE 18     def __init__(self, iterable=None):

IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

RUNINGPART:LinkedList  INPART:False
CODE LINE 19         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 20         Init

RUNINGPART:LinkedList  INPART:False
CODE LINE 21         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 22         self.__root = root = Link()         

RUNINGPART:LinkedList  INPART:False
CODE LINE 23         root.prev = root.next = root

RUNINGPART:LinkedList  INPART:False
CODE LINE 24         self.__map = {}                     # key --> link

RUNINGPART:LinkedList  INPART:False
CODE LINE 25         if iterable is not None:

RUNINGPART:LinkedList  INPART:False
CODE LINE 26             self |= iterable

RUNINGPART:LinkedList  INPART:False
BLANK LINE 7 

RUNINGPART:LinkedList  INPART:False
CODE LINE 27     def __len__(self):

IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 28         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 29         Length for the LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 30         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 31         return len(self.__map)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 8 

RUNINGPART:LinkedList  INPART:False
CODE LINE 32     def __contains__(self, key):

IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 33         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 34         Return Content of LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 35         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 36         return key in self.__map

RUNINGPART:LinkedList  INPART:False
BLANK LINE 9 

RUNINGPART:LinkedList  INPART:False
CODE LINE 37     def add(self, key):

IN PART LinkedList  ADD ITEM add:     def add(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 38         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 39         Add Node

RUNINGPART:LinkedList  INPART:False
CODE LINE 40         Store new key in a new link at the end of the linked list

RUNINGPART:LinkedList  INPART:False
CODE LINE 41         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 42         if key not in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 43             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 44             Not Element Eq in the list

RUNINGPART:LinkedList  INPART:False
CODE LINE 45             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 46             self.__map[key] = link = Link()            

RUNINGPART:LinkedList  INPART:False
CODE LINE 47             root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 48             last = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 49             link.prev, link.next, link.key = last, root, key

RUNINGPART:LinkedList  INPART:False
CODE LINE 50             last.next = root.prev = proxy(link)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 10     

RUNINGPART:LinkedList  INPART:False
CODE LINE 51     def head(self):

IN PART LinkedList  ADD ITEM head:     def head(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 52         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 53         Return Head

RUNINGPART:LinkedList  INPART:False
CODE LINE 54         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 55         return list(self)[0],list(self)[-1] 

RUNINGPART:LinkedList  INPART:False
BLANK LINE 11         

RUNINGPART:LinkedList  INPART:False
BLANK LINE 12 

RUNINGPART:LinkedList  INPART:False
CODE LINE 56     def discard(self, key):

IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 57         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 58         Remove an existing item using self.__map to find the link which is

RUNINGPART:LinkedList  INPART:False
CODE LINE 59         then removed by updating the links in the predecessor and successors.

RUNINGPART:LinkedList  INPART:False
CODE LINE 60         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 61         if key in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 62             link = self.__map.pop(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 63             link.prev.next = link.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 64             link.next.prev = link.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 13 

RUNINGPART:LinkedList  INPART:False
CODE LINE 65     def __iter__(self):

IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 66         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 67         iteration for the Next Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 68         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 69         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 70         curr = root.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 71         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 72             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 73             curr = curr.next

RUNINGPART:LinkedList  INPART:False
BLANK LINE 14 

RUNINGPART:LinkedList  INPART:False
CODE LINE 74     def __reversed__(self):

IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 75         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 76         iteration in reverse mode Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 77         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 78         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 79         curr = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 80         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 81             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 82             curr = curr.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 15 

RUNINGPART:LinkedList  INPART:False
CODE LINE 83     def pop(self, last=True):

IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

RUNINGPART:LinkedList  INPART:False
CODE LINE 84         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 85         pop key

RUNINGPART:LinkedList  INPART:False
CODE LINE 86         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 87         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 88             raise KeyError('set is empty')

RUNINGPART:LinkedList  INPART:False
CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

RUNINGPART:LinkedList  INPART:False
CODE LINE 90         self.discard(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 91         return key

RUNINGPART:LinkedList  INPART:False
BLANK LINE 16 

RUNINGPART:LinkedList  INPART:False
CODE LINE 92     def __repr__(self):

IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 93         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 94         String Conversion representation of object LinkeList repr()

RUNINGPART:LinkedList  INPART:False
CODE LINE 95         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 96         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 97             return '%s()' % (self.__class__.__name__,)

RUNINGPART:LinkedList  INPART:False
CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

RUNINGPART:LinkedList  INPART:False
BLANK LINE 17 

RUNINGPART:LinkedList  INPART:False
CODE LINE 99     def __eq__(self, other):

IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

RUNINGPART:LinkedList  INPART:False
CODE LINE 100         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 101         Method for de Equal comparation.

RUNINGPART:LinkedList  INPART:False
CODE LINE 102         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 103         if isinstance(other, LinkedList):

RUNINGPART:LinkedList  INPART:False
CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

RUNINGPART:LinkedList  INPART:False
CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7f77b7be2a90>, 'LinkedList': <__main__.Item object at 0x7f77b7be2b50>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

RUNINGPART:Link  INPART:True
CODE LINE 9     '''

RUNINGPART:Link  INPART:False
CODE LINE 10     The proper use of __slots__ is to save space in objects.

RUNINGPART:Link  INPART:False
CODE LINE 11     '''

RUNINGPART:Link  INPART:False
CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

RUNINGPART:Link  INPART:False
BLANK LINE 5 

RUNINGPART:Link  INPART:False
CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

RUNINGPART:LinkedList  INPART:True
CODE LINE 14     '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 15     LinkedLink

RUNINGPART:LinkedList  INPART:False
CODE LINE 16     Set the remembers the order elements were added

RUNINGPART:LinkedList  INPART:False
CODE LINE 17     '''

RUNINGPART:LinkedList  INPART:False
BLANK LINE 6 

RUNINGPART:LinkedList  INPART:False
CODE LINE 18     def __init__(self, iterable=None):

IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

RUNINGPART:LinkedList  INPART:False
CODE LINE 19         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 20         Init

RUNINGPART:LinkedList  INPART:False
CODE LINE 21         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 22         self.__root = root = Link()         

RUNINGPART:LinkedList  INPART:False
CODE LINE 23         root.prev = root.next = root

RUNINGPART:LinkedList  INPART:False
CODE LINE 24         self.__map = {}                     # key --> link

RUNINGPART:LinkedList  INPART:False
CODE LINE 25         if iterable is not None:

RUNINGPART:LinkedList  INPART:False
CODE LINE 26             self |= iterable

RUNINGPART:LinkedList  INPART:False
BLANK LINE 7 

RUNINGPART:LinkedList  INPART:False
CODE LINE 27     def __len__(self):

IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 28         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 29         Length for the LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 30         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 31         return len(self.__map)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 8 

RUNINGPART:LinkedList  INPART:False
CODE LINE 32     def __contains__(self, key):

IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 33         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 34         Return Content of LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 35         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 36         return key in self.__map

RUNINGPART:LinkedList  INPART:False
BLANK LINE 9 

RUNINGPART:LinkedList  INPART:False
CODE LINE 37     def add(self, key):

IN PART LinkedList  ADD ITEM add:     def add(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 38         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 39         Add Node

RUNINGPART:LinkedList  INPART:False
CODE LINE 40         Store new key in a new link at the end of the linked list

RUNINGPART:LinkedList  INPART:False
CODE LINE 41         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 42         if key not in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 43             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 44             Not Element Eq in the list

RUNINGPART:LinkedList  INPART:False
CODE LINE 45             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 46             self.__map[key] = link = Link()            

RUNINGPART:LinkedList  INPART:False
CODE LINE 47             root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 48             last = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 49             link.prev, link.next, link.key = last, root, key

RUNINGPART:LinkedList  INPART:False
CODE LINE 50             last.next = root.prev = proxy(link)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 10     

RUNINGPART:LinkedList  INPART:False
CODE LINE 51     def head(self):

IN PART LinkedList  ADD ITEM head:     def head(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 52         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 53         Return Head

RUNINGPART:LinkedList  INPART:False
CODE LINE 54         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 55         return list(self)[0],list(self)[-1] 

RUNINGPART:LinkedList  INPART:False
BLANK LINE 11         

RUNINGPART:LinkedList  INPART:False
BLANK LINE 12 

RUNINGPART:LinkedList  INPART:False
CODE LINE 56     def discard(self, key):

IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 57         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 58         Remove an existing item using self.__map to find the link which is

RUNINGPART:LinkedList  INPART:False
CODE LINE 59         then removed by updating the links in the predecessor and successors.

RUNINGPART:LinkedList  INPART:False
CODE LINE 60         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 61         if key in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 62             link = self.__map.pop(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 63             link.prev.next = link.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 64             link.next.prev = link.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 13 

RUNINGPART:LinkedList  INPART:False
CODE LINE 65     def __iter__(self):

IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 66         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 67         iteration for the Next Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 68         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 69         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 70         curr = root.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 71         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 72             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 73             curr = curr.next

RUNINGPART:LinkedList  INPART:False
BLANK LINE 14 

RUNINGPART:LinkedList  INPART:False
CODE LINE 74     def __reversed__(self):

IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 75         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 76         iteration in reverse mode Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 77         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 78         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 79         curr = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 80         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 81             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 82             curr = curr.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 15 

RUNINGPART:LinkedList  INPART:False
CODE LINE 83     def pop(self, last=True):

IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

RUNINGPART:LinkedList  INPART:False
CODE LINE 84         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 85         pop key

RUNINGPART:LinkedList  INPART:False
CODE LINE 86         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 87         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 88             raise KeyError('set is empty')

RUNINGPART:LinkedList  INPART:False
CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

RUNINGPART:LinkedList  INPART:False
CODE LINE 90         self.discard(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 91         return key

RUNINGPART:LinkedList  INPART:False
BLANK LINE 16 

RUNINGPART:LinkedList  INPART:False
CODE LINE 92     def __repr__(self):

IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 93         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 94         String Conversion representation of object LinkeList repr()

RUNINGPART:LinkedList  INPART:False
CODE LINE 95         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 96         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 97             return '%s()' % (self.__class__.__name__,)

RUNINGPART:LinkedList  INPART:False
CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

RUNINGPART:LinkedList  INPART:False
BLANK LINE 17 

RUNINGPART:LinkedList  INPART:False
CODE LINE 99     def __eq__(self, other):

IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

RUNINGPART:LinkedList  INPART:False
CODE LINE 100         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 101         Method for de Equal comparation.

RUNINGPART:LinkedList  INPART:False
CODE LINE 102         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 103         if isinstance(other, LinkedList):

RUNINGPART:LinkedList  INPART:False
CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

RUNINGPART:LinkedList  INPART:False
CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x7fa5152c8a90>, 'LinkedList': <__main__.Item object at 0x7fa5152c8b50>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

RUNINGPART:Link  INPART:True
CODE LINE 9     '''

IDENT: False
RUNINGPART:Link  INPART:False
CODE LINE 10     The proper use of __slots__ is to save space in objects.

RUNINGPART:Link  INPART:False
CODE LINE 11     '''

RUNINGPART:Link  INPART:False
CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

RUNINGPART:Link  INPART:False
BLANK LINE 5 

RUNINGPART:Link  INPART:False
CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

RUNINGPART:LinkedList  INPART:True
CODE LINE 14     '''

IDENT: False
RUNINGPART:LinkedList  INPART:False
CODE LINE 15     LinkedLink

RUNINGPART:LinkedList  INPART:False
CODE LINE 16     Set the remembers the order elements were added

RUNINGPART:LinkedList  INPART:False
CODE LINE 17     '''

RUNINGPART:LinkedList  INPART:False
BLANK LINE 6 

RUNINGPART:LinkedList  INPART:False
CODE LINE 18     def __init__(self, iterable=None):

IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

RUNINGPART:LinkedList  INPART:False
CODE LINE 19         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 20         Init

RUNINGPART:LinkedList  INPART:False
CODE LINE 21         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 22         self.__root = root = Link()         

RUNINGPART:LinkedList  INPART:False
CODE LINE 23         root.prev = root.next = root

RUNINGPART:LinkedList  INPART:False
CODE LINE 24         self.__map = {}                     # key --> link

RUNINGPART:LinkedList  INPART:False
CODE LINE 25         if iterable is not None:

RUNINGPART:LinkedList  INPART:False
CODE LINE 26             self |= iterable

RUNINGPART:LinkedList  INPART:False
BLANK LINE 7 

RUNINGPART:LinkedList  INPART:False
CODE LINE 27     def __len__(self):

IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 28         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 29         Length for the LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 30         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 31         return len(self.__map)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 8 

RUNINGPART:LinkedList  INPART:False
CODE LINE 32     def __contains__(self, key):

IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 33         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 34         Return Content of LinkedList

RUNINGPART:LinkedList  INPART:False
CODE LINE 35         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 36         return key in self.__map

RUNINGPART:LinkedList  INPART:False
BLANK LINE 9 

RUNINGPART:LinkedList  INPART:False
CODE LINE 37     def add(self, key):

IN PART LinkedList  ADD ITEM add:     def add(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 38         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 39         Add Node

RUNINGPART:LinkedList  INPART:False
CODE LINE 40         Store new key in a new link at the end of the linked list

RUNINGPART:LinkedList  INPART:False
CODE LINE 41         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 42         if key not in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 43             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 44             Not Element Eq in the list

RUNINGPART:LinkedList  INPART:False
CODE LINE 45             '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 46             self.__map[key] = link = Link()            

RUNINGPART:LinkedList  INPART:False
CODE LINE 47             root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 48             last = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 49             link.prev, link.next, link.key = last, root, key

RUNINGPART:LinkedList  INPART:False
CODE LINE 50             last.next = root.prev = proxy(link)

RUNINGPART:LinkedList  INPART:False
BLANK LINE 10     

RUNINGPART:LinkedList  INPART:False
CODE LINE 51     def head(self):

IN PART LinkedList  ADD ITEM head:     def head(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 52         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 53         Return Head

RUNINGPART:LinkedList  INPART:False
CODE LINE 54         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 55         return list(self)[0],list(self)[-1] 

RUNINGPART:LinkedList  INPART:False
BLANK LINE 11         

RUNINGPART:LinkedList  INPART:False
BLANK LINE 12 

RUNINGPART:LinkedList  INPART:False
CODE LINE 56     def discard(self, key):

IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

RUNINGPART:LinkedList  INPART:False
CODE LINE 57         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 58         Remove an existing item using self.__map to find the link which is

RUNINGPART:LinkedList  INPART:False
CODE LINE 59         then removed by updating the links in the predecessor and successors.

RUNINGPART:LinkedList  INPART:False
CODE LINE 60         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 61         if key in self.__map:

RUNINGPART:LinkedList  INPART:False
CODE LINE 62             link = self.__map.pop(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 63             link.prev.next = link.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 64             link.next.prev = link.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 13 

RUNINGPART:LinkedList  INPART:False
CODE LINE 65     def __iter__(self):

IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 66         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 67         iteration for the Next Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 68         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 69         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 70         curr = root.next

RUNINGPART:LinkedList  INPART:False
CODE LINE 71         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 72             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 73             curr = curr.next

RUNINGPART:LinkedList  INPART:False
BLANK LINE 14 

RUNINGPART:LinkedList  INPART:False
CODE LINE 74     def __reversed__(self):

IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 75         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 76         iteration in reverse mode Method

RUNINGPART:LinkedList  INPART:False
CODE LINE 77         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 78         root = self.__root

RUNINGPART:LinkedList  INPART:False
CODE LINE 79         curr = root.prev

RUNINGPART:LinkedList  INPART:False
CODE LINE 80         while curr is not root:

RUNINGPART:LinkedList  INPART:False
CODE LINE 81             yield curr.key

RUNINGPART:LinkedList  INPART:False
CODE LINE 82             curr = curr.prev

RUNINGPART:LinkedList  INPART:False
BLANK LINE 15 

RUNINGPART:LinkedList  INPART:False
CODE LINE 83     def pop(self, last=True):

IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

RUNINGPART:LinkedList  INPART:False
CODE LINE 84         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 85         pop key

RUNINGPART:LinkedList  INPART:False
CODE LINE 86         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 87         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 88             raise KeyError('set is empty')

RUNINGPART:LinkedList  INPART:False
CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

RUNINGPART:LinkedList  INPART:False
CODE LINE 90         self.discard(key)

RUNINGPART:LinkedList  INPART:False
CODE LINE 91         return key

RUNINGPART:LinkedList  INPART:False
BLANK LINE 16 

RUNINGPART:LinkedList  INPART:False
CODE LINE 92     def __repr__(self):

IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

RUNINGPART:LinkedList  INPART:False
CODE LINE 93         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 94         String Conversion representation of object LinkeList repr()

RUNINGPART:LinkedList  INPART:False
CODE LINE 95         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 96         if not self:

RUNINGPART:LinkedList  INPART:False
CODE LINE 97             return '%s()' % (self.__class__.__name__,)

RUNINGPART:LinkedList  INPART:False
CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

RUNINGPART:LinkedList  INPART:False
BLANK LINE 17 

RUNINGPART:LinkedList  INPART:False
CODE LINE 99     def __eq__(self, other):

IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

RUNINGPART:LinkedList  INPART:False
CODE LINE 100         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 101         Method for de Equal comparation.

RUNINGPART:LinkedList  INPART:False
CODE LINE 102         '''

RUNINGPART:LinkedList  INPART:False
CODE LINE 103         if isinstance(other, LinkedList):

RUNINGPART:LinkedList  INPART:False
CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

RUNINGPART:LinkedList  INPART:False
CODE LINE 105         return not self.isdisjoint(other)

===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0x2694a90>, 'LinkedList': <__main__.Item object at 0x2694b50>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

RUNINGPART:Link  INPART:True
CODE LINE 9     '''

IDENT: 1
START COUNTING
RUNINGPART:False  INPART:False
COMENT LINE 1 #!/usr/bin/env python2.6

RUNINGPART:False  INPART:False
COMENT LINE 2 # -*- coding: utf-8 -*-

RUNINGPART:False  INPART:False
COMENT LINE 3 #

RUNINGPART:False  INPART:False
COMENT LINE 4 #       mean_std.py

RUNINGPART:False  INPART:False
COMENT LINE 5 #       Copyright 2010 arpagon <arpagon@gmail.com.co>

RUNINGPART:False  INPART:False
COMENT LINE 6 #       

RUNINGPART:False  INPART:False
COMENT LINE 7 #       This program is free software; you can redistribute it and/or modify

RUNINGPART:False  INPART:False
COMENT LINE 8 #       it under the terms of the GNU General Public License as published by

RUNINGPART:False  INPART:False
COMENT LINE 9 #       the Free Software Foundation; either version 2 of the License, or

RUNINGPART:False  INPART:False
COMENT LINE 10 #       (at your option) any later version.

RUNINGPART:False  INPART:False
COMENT LINE 11 #       

RUNINGPART:False  INPART:False
COMENT LINE 12 #       This program is distributed in the hope that it will be useful,

RUNINGPART:False  INPART:False
COMENT LINE 13 #       but WITHOUT ANY WARRANTY; without even the implied warranty of

RUNINGPART:False  INPART:False
COMENT LINE 14 #       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

RUNINGPART:False  INPART:False
COMENT LINE 15 #       GNU General Public License for more details.

RUNINGPART:False  INPART:False
COMENT LINE 16 #       

RUNINGPART:False  INPART:False
COMENT LINE 17 #       You should have received a copy of the GNU General Public License

RUNINGPART:False  INPART:False
COMENT LINE 18 #       along with this program; if not, write to the Free Software

RUNINGPART:False  INPART:False
COMENT LINE 19 #       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,

RUNINGPART:False  INPART:False
COMENT LINE 20 #       MA 02110-1301, USA.

RUNINGPART:False  INPART:False
BLANK LINE 1 

RUNINGPART:False  INPART:False
BLANK LINE 2 

RUNINGPART:False  INPART:False
CODE LINE 1 __version__ = "0.0.1"

RUNINGPART:False  INPART:False
CODE LINE 2 __license__ = """The GNU General Public License (GPL-2.0)"""

RUNINGPART:False  INPART:False
CODE LINE 3 __author__ = "Sebastian Rojo <http://www.sapian.com.co> arpagon@gamil.com"

RUNINGPART:False  INPART:False
CODE LINE 4 __contributors__ = []

RUNINGPART:False  INPART:False
CODE LINE 5 _debug = 0

RUNINGPART:False  INPART:False
BLANK LINE 3 

RUNINGPART:False  INPART:False
CODE LINE 6 import collections

RUNINGPART:False  INPART:False
CODE LINE 7 from weakref import proxy

RUNINGPART:False  INPART:False
BLANK LINE 4 

RUNINGPART:False  INPART:False
CODE LINE 8 class Link(object):

ADDED PART Link class Link(object):

RUNINGPART:Link  INPART:True
CODE LINE 9     '''

IDENT: 1
PART LENGTH Link: 2
RUNINGPART:Link  INPART:True
CODE LINE 10     The proper use of __slots__ is to save space in objects.

IDENT: 1
PART LENGTH Link: 3
RUNINGPART:Link  INPART:True
CODE LINE 11     '''

IDENT: 1
PART LENGTH Link: 4
RUNINGPART:Link  INPART:True
CODE LINE 12     __slots__ = 'prev', 'next', 'key', '__weakref__'

IDENT: 1
PART LENGTH Link: 5
RUNINGPART:Link  INPART:True
BLANK LINE 5 

RUNINGPART:Link  INPART:True
CODE LINE 13 class LinkedList(collections.MutableSet):

ADDED PART LinkedList class LinkedList(collections.MutableSet):

RUNINGPART:LinkedList  INPART:True
CODE LINE 14     '''

IDENT: 1
PART LENGTH LinkedList: 2
RUNINGPART:LinkedList  INPART:True
CODE LINE 15     LinkedLink

IDENT: 1
PART LENGTH LinkedList: 3
RUNINGPART:LinkedList  INPART:True
CODE LINE 16     Set the remembers the order elements were added

IDENT: 1
PART LENGTH LinkedList: 4
RUNINGPART:LinkedList  INPART:True
CODE LINE 17     '''

IDENT: 1
PART LENGTH LinkedList: 5
RUNINGPART:LinkedList  INPART:True
BLANK LINE 6 

RUNINGPART:LinkedList  INPART:True
CODE LINE 18     def __init__(self, iterable=None):

IN PART LinkedList  ADD ITEM __init__:     def __init__(self, iterable=None):

RUNINGPART:LinkedList  INPART:True
CODE LINE 19         '''

IDENT: 2
PART LENGTH LinkedList: 7
RUNINGPART:LinkedList  INPART:True
CODE LINE 20         Init

IDENT: 2
PART LENGTH LinkedList: 8
RUNINGPART:LinkedList  INPART:True
CODE LINE 21         '''

IDENT: 2
PART LENGTH LinkedList: 9
RUNINGPART:LinkedList  INPART:True
CODE LINE 22         self.__root = root = Link()         

IDENT: 2
PART LENGTH LinkedList: 10
RUNINGPART:LinkedList  INPART:True
CODE LINE 23         root.prev = root.next = root

IDENT: 2
PART LENGTH LinkedList: 11
RUNINGPART:LinkedList  INPART:True
CODE LINE 24         self.__map = {}                     # key --> link

IDENT: 7
PART LENGTH LinkedList: 12
RUNINGPART:LinkedList  INPART:True
CODE LINE 25         if iterable is not None:

IDENT: 2
PART LENGTH LinkedList: 13
RUNINGPART:LinkedList  INPART:True
CODE LINE 26             self |= iterable

IDENT: 3
PART LENGTH LinkedList: 14
RUNINGPART:LinkedList  INPART:True
BLANK LINE 7 

RUNINGPART:LinkedList  INPART:True
CODE LINE 27     def __len__(self):

IN PART LinkedList  ADD ITEM __len__:     def __len__(self):

RUNINGPART:LinkedList  INPART:True
CODE LINE 28         '''

IDENT: 2
PART LENGTH LinkedList: 16
RUNINGPART:LinkedList  INPART:True
CODE LINE 29         Length for the LinkedList

IDENT: 2
PART LENGTH LinkedList: 17
RUNINGPART:LinkedList  INPART:True
CODE LINE 30         '''

IDENT: 2
PART LENGTH LinkedList: 18
RUNINGPART:LinkedList  INPART:True
CODE LINE 31         return len(self.__map)

IDENT: 2
PART LENGTH LinkedList: 19
RUNINGPART:LinkedList  INPART:True
BLANK LINE 8 

RUNINGPART:LinkedList  INPART:True
CODE LINE 32     def __contains__(self, key):

IN PART LinkedList  ADD ITEM __contains__:     def __contains__(self, key):

RUNINGPART:LinkedList  INPART:True
CODE LINE 33         '''

IDENT: 2
PART LENGTH LinkedList: 21
RUNINGPART:LinkedList  INPART:True
CODE LINE 34         Return Content of LinkedList

IDENT: 2
PART LENGTH LinkedList: 22
RUNINGPART:LinkedList  INPART:True
CODE LINE 35         '''

IDENT: 2
PART LENGTH LinkedList: 23
RUNINGPART:LinkedList  INPART:True
CODE LINE 36         return key in self.__map

IDENT: 2
PART LENGTH LinkedList: 24
RUNINGPART:LinkedList  INPART:True
BLANK LINE 9 

RUNINGPART:LinkedList  INPART:True
CODE LINE 37     def add(self, key):

IN PART LinkedList  ADD ITEM add:     def add(self, key):

RUNINGPART:LinkedList  INPART:True
CODE LINE 38         '''

IDENT: 2
PART LENGTH LinkedList: 26
RUNINGPART:LinkedList  INPART:True
CODE LINE 39         Add Node

IDENT: 2
PART LENGTH LinkedList: 27
RUNINGPART:LinkedList  INPART:True
CODE LINE 40         Store new key in a new link at the end of the linked list

IDENT: 2
PART LENGTH LinkedList: 28
RUNINGPART:LinkedList  INPART:True
CODE LINE 41         '''

IDENT: 2
PART LENGTH LinkedList: 29
RUNINGPART:LinkedList  INPART:True
CODE LINE 42         if key not in self.__map:

IDENT: 2
PART LENGTH LinkedList: 30
RUNINGPART:LinkedList  INPART:True
CODE LINE 43             '''

IDENT: 3
PART LENGTH LinkedList: 31
RUNINGPART:LinkedList  INPART:True
CODE LINE 44             Not Element Eq in the list

IDENT: 3
PART LENGTH LinkedList: 32
RUNINGPART:LinkedList  INPART:True
CODE LINE 45             '''

IDENT: 3
PART LENGTH LinkedList: 33
RUNINGPART:LinkedList  INPART:True
CODE LINE 46             self.__map[key] = link = Link()            

IDENT: 3
PART LENGTH LinkedList: 34
RUNINGPART:LinkedList  INPART:True
CODE LINE 47             root = self.__root

IDENT: 3
PART LENGTH LinkedList: 35
RUNINGPART:LinkedList  INPART:True
CODE LINE 48             last = root.prev

IDENT: 3
PART LENGTH LinkedList: 36
RUNINGPART:LinkedList  INPART:True
CODE LINE 49             link.prev, link.next, link.key = last, root, key

IDENT: 3
PART LENGTH LinkedList: 37
RUNINGPART:LinkedList  INPART:True
CODE LINE 50             last.next = root.prev = proxy(link)

IDENT: 3
PART LENGTH LinkedList: 38
RUNINGPART:LinkedList  INPART:True
BLANK LINE 10     

RUNINGPART:LinkedList  INPART:True
CODE LINE 51     def head(self):

IN PART LinkedList  ADD ITEM head:     def head(self):

RUNINGPART:LinkedList  INPART:True
CODE LINE 52         '''

IDENT: 2
PART LENGTH LinkedList: 40
RUNINGPART:LinkedList  INPART:True
CODE LINE 53         Return Head

IDENT: 2
PART LENGTH LinkedList: 41
RUNINGPART:LinkedList  INPART:True
CODE LINE 54         '''

IDENT: 2
PART LENGTH LinkedList: 42
RUNINGPART:LinkedList  INPART:True
CODE LINE 55         return list(self)[0],list(self)[-1] 

IDENT: 2
PART LENGTH LinkedList: 43
RUNINGPART:LinkedList  INPART:True
BLANK LINE 11         

RUNINGPART:LinkedList  INPART:True
BLANK LINE 12 

RUNINGPART:LinkedList  INPART:True
CODE LINE 56     def discard(self, key):

IN PART LinkedList  ADD ITEM discard:     def discard(self, key):

RUNINGPART:LinkedList  INPART:True
CODE LINE 57         '''

IDENT: 2
PART LENGTH LinkedList: 45
RUNINGPART:LinkedList  INPART:True
CODE LINE 58         Remove an existing item using self.__map to find the link which is

IDENT: 2
PART LENGTH LinkedList: 46
RUNINGPART:LinkedList  INPART:True
CODE LINE 59         then removed by updating the links in the predecessor and successors.

IDENT: 2
PART LENGTH LinkedList: 47
RUNINGPART:LinkedList  INPART:True
CODE LINE 60         '''

IDENT: 2
PART LENGTH LinkedList: 48
RUNINGPART:LinkedList  INPART:True
CODE LINE 61         if key in self.__map:

IDENT: 2
PART LENGTH LinkedList: 49
RUNINGPART:LinkedList  INPART:True
CODE LINE 62             link = self.__map.pop(key)

IDENT: 3
PART LENGTH LinkedList: 50
RUNINGPART:LinkedList  INPART:True
CODE LINE 63             link.prev.next = link.next

IDENT: 3
PART LENGTH LinkedList: 51
RUNINGPART:LinkedList  INPART:True
CODE LINE 64             link.next.prev = link.prev

IDENT: 3
PART LENGTH LinkedList: 52
RUNINGPART:LinkedList  INPART:True
BLANK LINE 13 

RUNINGPART:LinkedList  INPART:True
CODE LINE 65     def __iter__(self):

IN PART LinkedList  ADD ITEM __iter__:     def __iter__(self):

RUNINGPART:LinkedList  INPART:True
CODE LINE 66         '''

IDENT: 2
PART LENGTH LinkedList: 54
RUNINGPART:LinkedList  INPART:True
CODE LINE 67         iteration for the Next Method

IDENT: 2
PART LENGTH LinkedList: 55
RUNINGPART:LinkedList  INPART:True
CODE LINE 68         '''

IDENT: 2
PART LENGTH LinkedList: 56
RUNINGPART:LinkedList  INPART:True
CODE LINE 69         root = self.__root

IDENT: 2
PART LENGTH LinkedList: 57
RUNINGPART:LinkedList  INPART:True
CODE LINE 70         curr = root.next

IDENT: 2
PART LENGTH LinkedList: 58
RUNINGPART:LinkedList  INPART:True
CODE LINE 71         while curr is not root:

IDENT: 2
PART LENGTH LinkedList: 59
RUNINGPART:LinkedList  INPART:True
CODE LINE 72             yield curr.key

IDENT: 3
PART LENGTH LinkedList: 60
RUNINGPART:LinkedList  INPART:True
CODE LINE 73             curr = curr.next

IDENT: 3
PART LENGTH LinkedList: 61
RUNINGPART:LinkedList  INPART:True
BLANK LINE 14 

RUNINGPART:LinkedList  INPART:True
CODE LINE 74     def __reversed__(self):

IN PART LinkedList  ADD ITEM __reversed__:     def __reversed__(self):

RUNINGPART:LinkedList  INPART:True
CODE LINE 75         '''

IDENT: 2
PART LENGTH LinkedList: 63
RUNINGPART:LinkedList  INPART:True
CODE LINE 76         iteration in reverse mode Method

IDENT: 2
PART LENGTH LinkedList: 64
RUNINGPART:LinkedList  INPART:True
CODE LINE 77         '''

IDENT: 2
PART LENGTH LinkedList: 65
RUNINGPART:LinkedList  INPART:True
CODE LINE 78         root = self.__root

IDENT: 2
PART LENGTH LinkedList: 66
RUNINGPART:LinkedList  INPART:True
CODE LINE 79         curr = root.prev

IDENT: 2
PART LENGTH LinkedList: 67
RUNINGPART:LinkedList  INPART:True
CODE LINE 80         while curr is not root:

IDENT: 2
PART LENGTH LinkedList: 68
RUNINGPART:LinkedList  INPART:True
CODE LINE 81             yield curr.key

IDENT: 3
PART LENGTH LinkedList: 69
RUNINGPART:LinkedList  INPART:True
CODE LINE 82             curr = curr.prev

IDENT: 3
PART LENGTH LinkedList: 70
RUNINGPART:LinkedList  INPART:True
BLANK LINE 15 

RUNINGPART:LinkedList  INPART:True
CODE LINE 83     def pop(self, last=True):

IN PART LinkedList  ADD ITEM pop:     def pop(self, last=True):

RUNINGPART:LinkedList  INPART:True
CODE LINE 84         '''

IDENT: 2
PART LENGTH LinkedList: 72
RUNINGPART:LinkedList  INPART:True
CODE LINE 85         pop key

IDENT: 2
PART LENGTH LinkedList: 73
RUNINGPART:LinkedList  INPART:True
CODE LINE 86         '''

IDENT: 2
PART LENGTH LinkedList: 74
RUNINGPART:LinkedList  INPART:True
CODE LINE 87         if not self:

IDENT: 2
PART LENGTH LinkedList: 75
RUNINGPART:LinkedList  INPART:True
CODE LINE 88             raise KeyError('set is empty')

IDENT: 3
PART LENGTH LinkedList: 76
RUNINGPART:LinkedList  INPART:True
CODE LINE 89         key = next(reversed(self)) if last else next(iter(self))

IDENT: 2
PART LENGTH LinkedList: 77
RUNINGPART:LinkedList  INPART:True
CODE LINE 90         self.discard(key)

IDENT: 2
PART LENGTH LinkedList: 78
RUNINGPART:LinkedList  INPART:True
CODE LINE 91         return key

IDENT: 2
PART LENGTH LinkedList: 79
RUNINGPART:LinkedList  INPART:True
BLANK LINE 16 

RUNINGPART:LinkedList  INPART:True
CODE LINE 92     def __repr__(self):

IN PART LinkedList  ADD ITEM __repr__:     def __repr__(self):

RUNINGPART:LinkedList  INPART:True
CODE LINE 93         '''

IDENT: 2
PART LENGTH LinkedList: 81
RUNINGPART:LinkedList  INPART:True
CODE LINE 94         String Conversion representation of object LinkeList repr()

IDENT: 2
PART LENGTH LinkedList: 82
RUNINGPART:LinkedList  INPART:True
CODE LINE 95         '''

IDENT: 2
PART LENGTH LinkedList: 83
RUNINGPART:LinkedList  INPART:True
CODE LINE 96         if not self:

IDENT: 2
PART LENGTH LinkedList: 84
RUNINGPART:LinkedList  INPART:True
CODE LINE 97             return '%s()' % (self.__class__.__name__,)

IDENT: 3
PART LENGTH LinkedList: 85
RUNINGPART:LinkedList  INPART:True
CODE LINE 98         return '%s(%r)' % (self.__class__.__name__, list(self))

IDENT: 2
PART LENGTH LinkedList: 86
RUNINGPART:LinkedList  INPART:True
BLANK LINE 17 

RUNINGPART:LinkedList  INPART:True
CODE LINE 99     def __eq__(self, other):

IN PART LinkedList  ADD ITEM __eq__:     def __eq__(self, other):

RUNINGPART:LinkedList  INPART:True
CODE LINE 100         '''

IDENT: 2
PART LENGTH LinkedList: 88
RUNINGPART:LinkedList  INPART:True
CODE LINE 101         Method for de Equal comparation.

IDENT: 2
PART LENGTH LinkedList: 89
RUNINGPART:LinkedList  INPART:True
CODE LINE 102         '''

IDENT: 2
PART LENGTH LinkedList: 90
RUNINGPART:LinkedList  INPART:True
CODE LINE 103         if isinstance(other, LinkedList):

IDENT: 2
PART LENGTH LinkedList: 91
RUNINGPART:LinkedList  INPART:True
CODE LINE 104             return len(self) == len(other) and list(self) == list(other)

IDENT: 3
PART LENGTH LinkedList: 92
RUNINGPART:LinkedList  INPART:True
CODE LINE 105         return not self.isdisjoint(other)

IDENT: 2
PART LENGTH LinkedList: 93
===TOTAL===
 CODE LINES:105
 PARTS:{'Link': <__main__.Item object at 0xee5a90>, 'LinkedList': <__main__.Item object at 0xee5ad0>} 
 TOTAL LINES:142 
 BLANK LINE:17 
 COMMEN_LINES:20
